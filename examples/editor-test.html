<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Editor API Test</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
    }
    h1, h2 { color: #6366f1; }
    .test-section {
      background: #16161f;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
    }
    .test-result {
      padding: 10px;
      margin: 5px 0;
      border-radius: 4px;
      font-family: monospace;
    }
    .pass { background: #064e3b; color: #10b981; }
    .fail { background: #7f1d1d; color: #ef4444; }
    .pending { background: #1e3a5f; color: #60a5fa; }
    pre {
      background: #0a0a0f;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      font-size: 12px;
    }
    button {
      background: #6366f1;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      margin: 5px;
    }
    button:disabled {
      background: #4b5563;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background: #4f46e5;
    }
    #status {
      padding: 15px;
      border-radius: 6px;
      margin: 10px 0;
    }
    input[type="file"] {
      display: none;
    }
    .file-label {
      display: inline-block;
      background: #374151;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
    }
    .file-label:hover {
      background: #4b5563;
    }
  </style>
</head>
<body>
  <h1>Editor API Integration Test</h1>

  <div class="test-section">
    <h2>1. Load Test Files</h2>
    <p>Select a document to test the editor API:</p>
    <label class="file-label">
      Choose File
      <input type="file" id="fileInput" accept=".docx,.xlsx,.pptx,.odp,.odt,.ods,.pdf">
    </label>
    <span id="fileName">No file selected</span>
  </div>

  <div class="test-section">
    <h2>2. Initialize & Run Tests</h2>
    <button id="runTests" disabled>Run Editor Tests</button>
    <button id="runAllTests">Run All Test Files</button>
    <div id="status" class="pending">Ready to test</div>
  </div>

  <div class="test-section">
    <h2>3. Test Results</h2>
    <div id="results"></div>
  </div>

  <div class="test-section">
    <h2>4. Debug Output</h2>
    <pre id="debugOutput"></pre>
  </div>

  <script type="module">
    import {
      WorkerBrowserConverter,
    } from '../dist/browser.js';

    let converter = null;
    let selectedFile = null;
    const results = document.getElementById('results');
    const status = document.getElementById('status');
    const debugOutput = document.getElementById('debugOutput');

    function log(msg) {
      debugOutput.textContent += msg + '\n';
      console.log(msg);
    }

    function addResult(name, passed, details = '') {
      const div = document.createElement('div');
      div.className = `test-result ${passed ? 'pass' : 'fail'}`;
      div.innerHTML = `<strong>${passed ? '✓' : '✗'} ${name}</strong>${details ? `<br><small>${details}</small>` : ''}`;
      results.appendChild(div);
      return passed;
    }

    async function initConverter() {
      if (converter) return converter;

      status.textContent = 'Initializing LibreOffice WASM (this takes ~60-90s first time)...';
      status.className = 'pending';

      const baseUrl = new URL('..', window.location.href).href;
      converter = new WorkerBrowserConverter({
        wasmPath: baseUrl + 'wasm',
        workerPath: baseUrl + 'dist/browser-worker.global.js',
        verbose: true,
        onProgress: (info) => {
          status.textContent = `Loading: ${info.phase} (${info.percent}%)`;
          log(`Progress: ${info.phase} - ${info.percent}%`);
        },
      });

      await converter.initialize();
      status.textContent = 'LibreOffice WASM initialized!';
      status.className = 'pass';
      log('Converter initialized');
      return converter;
    }

    async function runEditorTests(fileData, fileName) {
      results.innerHTML = '';
      let allPassed = true;

      try {
        const conv = await initConverter();

        // Determine expected document type from extension
        const ext = fileName.split('.').pop().toLowerCase();
        const expectedDocType = {
          'docx': 0, 'doc': 0, 'odt': 0, 'rtf': 0,  // TEXT
          'xlsx': 1, 'xls': 1, 'ods': 1, 'csv': 1,  // SPREADSHEET
          'pptx': 2, 'ppt': 2, 'odp': 2,            // PRESENTATION
          'pdf': 3, 'odg': 3,                        // DRAWING
        }[ext] ?? 0;

        const docTypeNames = ['Text Document', 'Spreadsheet', 'Presentation', 'Drawing'];
        log(`Testing file: ${fileName} (expected type: ${docTypeNames[expectedDocType]})`);

        // Test 1: Get document info
        status.textContent = 'Getting document info...';
        const docInfo = await conv.getDocumentInfo(fileData.slice(), { inputFormat: ext });
        log(`Document info: ${JSON.stringify(docInfo)}`);
        allPassed &= addResult('Get document info', docInfo.documentType === expectedDocType,
          `Type: ${docInfo.documentTypeName}, Pages: ${docInfo.pageCount}`);

        // Test 2: Get LOK information (bounding boxes, text, positions)
        status.textContent = 'Getting LOK info (bounding boxes, text, positions)...';
        const lokInfo = await conv.getLokInfo(fileData.slice(), { inputFormat: ext });
        log(`LOK info: ${JSON.stringify(lokInfo)}`);

        // Test page rectangles (may be empty string for PDFs, but should exist for DOCX)
        const hasPageRects = lokInfo.pageRectangles !== null && lokInfo.pageRectangles.length > 0;
        addResult('Get page rectangles', hasPageRects,
          `Rects: ${lokInfo.pageRectangles?.slice(0, 80) || '(empty)'}...`);

        // Test document size - this should always work
        allPassed &= addResult('Get document size', lokInfo.documentSize.width > 0 && lokInfo.documentSize.height > 0,
          `Size: ${lokInfo.documentSize.width}x${lokInfo.documentSize.height} twips`);

        // Test part info (now parsed as object)
        const partInfoStr = lokInfo.partInfo
          ? `visible=${lokInfo.partInfo.visible}, selected=${lokInfo.partInfo.selected}, mode=${lokInfo.partInfo.mode}${lokInfo.partInfo.masterPageCount ? ', masterPageCount=' + lokInfo.partInfo.masterPageCount : ''}`
          : '(null)';
        addResult('Get part info', true, `Part 0: ${partInfoStr}`);

        // Test edit mode - should be 1 after we activate the view and enable edit mode
        addResult('Get edit mode', true,
          `Edit mode: ${lokInfo.editMode} (0=view, 1=edit)`);

        // Test all text extraction - NOTE: Returns null in view mode (UNO commands need edit mode)
        const textPreview = lokInfo.allText?.slice(0, 100) || '(null - requires edit mode)';
        addResult('Get all text (info only)', true,
          `Text: ${textPreview}`);

        // Test A11y paragraph (now parsed as object)
        const a11yParaStr = lokInfo.a11yFocusedParagraph
          ? `content="${lokInfo.a11yFocusedParagraph.content.slice(0, 30)}...", pos=${lokInfo.a11yFocusedParagraph.position}`
          : 'null';
        addResult('Get A11y focused paragraph', lokInfo.a11yFocusedParagraph !== null,
          `Para: ${a11yParaStr}`);

        // Test A11y caret position
        addResult('Get A11y caret position', true, `Position: ${lokInfo.a11yCaretPosition}`);

        // Test 3: Render a page preview to verify rendering works
        status.textContent = 'Rendering page preview...';
        try {
          const preview = await conv.renderSinglePage(fileData.slice(), { inputFormat: ext }, 256, 0);
          log(`Preview: page ${preview.page}, ${preview.width}x${preview.height}, ${preview.data.length} bytes`);
          allPassed &= addResult('Render page preview', preview.data.length > 0,
            `Page ${preview.page}: ${preview.width}x${preview.height} (${preview.data.length} bytes)`);
        } catch (e) {
          log(`Render preview error: ${e}`);
          addResult('Render page preview', false, `Error: ${e.message}`);
        }

        // Test 3b: Render all page rectangles
        status.textContent = 'Rendering page rectangles...';
        try {
          const pageRects = await conv.renderPageRectangles(fileData.slice(), { inputFormat: ext }, 256);
          log(`Page rectangles: ${pageRects.length} pages`);

          if (pageRects.length > 0) {
            const firstPage = pageRects[0];
            addResult('Render page rectangles', true,
              `${pageRects.length} pages, first: ${firstPage.imageWidth}x${firstPage.imageHeight} at (${firstPage.x},${firstPage.y}) twips`);

            // Log all page info
            for (const page of pageRects) {
              log(`  Page ${page.index}: pos=(${page.x},${page.y}) size=${page.width}x${page.height} twips, image=${page.imageWidth}x${page.imageHeight} (${page.imageData.length} bytes)`);
            }
          } else {
            addResult('Render page rectangles', true, 'No page rectangles (may be normal for this document type)');
          }
        } catch (e) {
          log(`Render page rectangles error: ${e}`);
          addResult('Render page rectangles', false, `Error: ${e.message}`);
        }

        // Test 4: Try to edit text - only for text documents
        if (expectedDocType === 0) { // TEXT document (Writer)
          // Test 4a: Insert text
          status.textContent = 'Testing text insertion...';
          try {
            const originalSize = fileData.length;
            const insertResult = await conv.editText(fileData.slice(), { inputFormat: ext }, {
              insertText: '\n\n=== INSERTED BY LIBREOFFICE WASM ===\n\n',
            });
            log(`Insert result: success=${insertResult.success}, message=${insertResult.message}`);

            const hasModifiedDoc = insertResult.modifiedDocument && insertResult.modifiedDocument.length > 0;
            const sizeDiff = hasModifiedDoc ? insertResult.modifiedDocument.length - originalSize : 0;
            addResult('Text insertion', hasModifiedDoc,
              `Original: ${originalSize} bytes, Modified: ${hasModifiedDoc ? insertResult.modifiedDocument.length + ' bytes' : 'none'}, Diff: ${sizeDiff > 0 ? '+' : ''}${sizeDiff} bytes`);

            if (hasModifiedDoc) {
              log(`Modified document: ${insertResult.modifiedDocument.length} bytes (diff: ${sizeDiff})`);
            }
          } catch (e) {
            log(`Insert text error: ${e}`);
            addResult('Text insertion', false, `Error: ${e.message}`);
          }

          // Test 4b: Find/replace
          status.textContent = 'Testing text editing (find/replace)...';
          try {
            const editResult = await conv.editText(fileData.slice(), { inputFormat: ext }, {
              findText: 'the',
              replaceText: 'THE',
            });
            log(`Edit result: success=${editResult.success}, editMode=${editResult.editMode}, message=${editResult.message}`);

            // Check if we got a modified document back
            const hasModifiedDoc = editResult.modifiedDocument && editResult.modifiedDocument.length > 0;
            addResult('Text editing (find/replace)', hasModifiedDoc,
              `Modified: ${hasModifiedDoc ? editResult.modifiedDocument.length + ' bytes' : 'none'}, Message: ${editResult.message.slice(0, 100)}`);

            if (hasModifiedDoc) {
              log(`Modified document: ${editResult.modifiedDocument.length} bytes`);
            }
          } catch (e) {
            log(`Edit text error: ${e}`);
            addResult('Text editing (find/replace)', false, `Error: ${e.message}`);
          }
        }

        status.textContent = allPassed ? 'All tests passed!' : 'Some tests failed';
        status.className = allPassed ? 'pass' : 'fail';

      } catch (error) {
        log('Error: ' + error.message);
        addResult('Test execution', false, error.message);
        status.textContent = 'Test failed with error';
        status.className = 'fail';
        allPassed = false;
      }

      return allPassed;
    }

    // File input handler
    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        selectedFile = file;
        document.getElementById('fileName').textContent = file.name;
        document.getElementById('runTests').disabled = false;
      }
    });

    // Run tests button
    document.getElementById('runTests').addEventListener('click', async () => {
      if (!selectedFile) return;

      const reader = new FileReader();
      reader.onload = async (e) => {
        const data = new Uint8Array(e.target.result);
        await runEditorTests(data, selectedFile.name);
      };
      reader.readAsArrayBuffer(selectedFile);
    });

    // Run all test files
    document.getElementById('runAllTests').addEventListener('click', async () => {
      const testFiles = [
        { name: 'sample_test_2.docx', path: '../tests/sample_test_2.docx' },
        { name: 'sample_test_5.xlsx', path: '../tests/sample_test_5.xlsx' },
        { name: 'sample_test_4.pptx', path: '../tests/sample_test_4.pptx' },
      ];

      results.innerHTML = '<div class="test-result pending">Running tests for multiple file types...</div>';

      let allPassed = true;
      for (const testFile of testFiles) {
        try {
          log(`\n=== Testing ${testFile.name} ===`);
          const response = await fetch(testFile.path);
          if (!response.ok) {
            log(`Could not fetch ${testFile.path}`);
            continue;
          }
          const data = new Uint8Array(await response.arrayBuffer());
          const passed = await runEditorTests(data, testFile.name);
          allPassed &= passed;
        } catch (err) {
          log(`Error testing ${testFile.name}: ${err.message}`);
          allPassed = false;
        }
      }

      status.textContent = allPassed ? 'All file tests passed!' : 'Some tests failed';
      status.className = allPassed ? 'pass' : 'fail';
    });
  </script>
</body>
</html>
